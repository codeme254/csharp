# Thread Synchronization With Mutex Class

Mutex also helps us to ensure that our code is thread-safe. That means when we run our code in a multi-threaded 
environment then we don’t end up with inconsistent results.

The Locks and Monitors ensure thread safety for threads that are InProcess i.e. the threads that are generated 
by the application itself i.e. Internal Threads. But if the threads are coming from OutProcess i.e. from external 
applications then Locks and Monitors have no control over them. Whereas Mutex ensures thread safety for threads that 
are Out-Process i.e. the threads that are generated by the external applications i.e. External Threads.

In simple words:  
Lock/Monitor work only within a single process. If two threads belong to the same application, lock/monitor
can synchronize them just fine. However, they cannot coordinate across different processes.

A Mutex can synchronize threads within the same process and across multiple processes.

![Mutex illustration](multithreading-mutex-illustration.png)

## An Example to Understand the Mutex Class
Let us first understand what is External Process Or External Threads and then we will understand Mutex in C#. Let us 
first create a console application and then copy and paste the below code into it.

```C#
using System;

namespace MutexDemo
{
    internal class Program
    {
        static void Main(string[] args)
        {
            Console.WriteLine("Applicatiton is running...");
            Console.ReadKey();
        }
    }
}
```

Now, build the project and go to the project’s bin\Debug directory and there you will find the application EXE file.

When you double-click on the Application EXE file, an external thread will execute the application code.

And now if you double-click multiple times, then each time a new external thread will be created and execute our 
application code as shown in the below image.

In the example below, we have double-clicked the exe file 3 times, so three external threads are accessing our
application at the same time.

![Example](multithreading-multiple-external.png)

If you want to restrict that only external thread access to our application code at any given point in time,
then we need to use the Mutex in C#.

Now, let us rewrite the previous example using the C# Mutex Class and see what happens when we try to access the 
application code multiple times from outside using External Threads, and then we will discuss the C# Mutex Class 
in detail.

Modify the code Program.cs class file as follows. So, when one external thread accesses our code, no more external 
threads can access the code. The following example exactly does the same using C# Mutex Class. This is one of 
the use cases of Mutex in C#.

Don't worry about the code, we will discuss in details:

```C#
using System;
using System.Threading;

namespace MutexDemo
{
    internal class Program
    {
        static void Main(string[] args)
        {
            using(Mutex mutex = new Mutex(false, "MutexDemo"))
            {
                // Check of another external thread is running
                if (!mutex.WaitOne(500,false))
                {
                    Console.WriteLine("An instance of the application is already running");
                    Console.ReadKey();
                    return;
                }
                Console.WriteLine("Application is running...");
                Console.ReadKey();
            }
        }
    }
}
```

Now close all the instances which are running. Then build the project and again go to the projects bin\Debug 
directory and again click on the Exe file for the first time. You will get the following result.

![Output on the first run](multithreading-mutex-1.png)

Now, again click on the EXE file. This time it will wait for 5 seconds and then it will give you the following 
message. This ensures that only one external thread can access our application code at any given point in time.

![Output on the second run](multithreading-mutex-2.png)

## What is Mutex Class in C#
Mutex works like a lock i.e. acquired an exclusive lock on a shared resource from concurrent access, but it works 
across multiple processes.

As we already discussed exclusive locking is basically used to ensure that at any given point in time, only 
one thread can enter into the critical section.

When two or more threads need to access a shared resource at the same time, the system needs a synchronization
mechanism to ensure that only one thread at a time uses the resource. Mutex is a synchronization mechanism that 
grants exclusive access to the shared resource to only one external thread. If a thread acquires a mutex, the 
second thread that wants to acquire that mutex is suspended until the first thread releases the mutex.

## Constructors and Methods of the Mutex Class in C#
Mutex is a sealed class and it is inherited from WaitHandle class. As it is a sealed class, so no further 
inheritance is possible i.e. no class can be derived from this sealed Mutex class in C#.

![Mutex class](multithreading-mutex-class.png)

## Constructors of the Mutex Class in C#
The Mutex Class in C# provides the following five constructors that we can use to create an instance of the Mutex class.
1. **Mutex()**: It initializes a new instance of the Mutex class with default properties.
2. **Mutex(bool initiallyOwned)**: It initializes a new instance of the Mutex class with a Boolean value that 
indicates whether the calling thread should have initial ownership of the mutex.
3. **Mutex(bool initiallyOwned, string name)**: It initializes a new instance of the System.Threading.Mutex class 
with a Boolean value that indicates whether the calling thread should have initial ownership of the mutex, 
and a string that is the name of the mutex.
4. **Mutex(bool initiallyOwned, string name, out bool createdNew)**:  It initializes a new instance of the 
System.Threading.Mutex class with a Boolean value that indicates whether the calling thread should have 
initial ownership of the mutex, a string that is the name of the mutex, and a Boolean value that, when the 
method returns, indicates whether the calling thread was granted initial ownership of the mutex.
5. **Mutex(bool initiallyOwned, string name, out bool createdNew, MutexSecurity mutexSecurity)**: It initializes a
new instance of the System.Threading.Mutex class with a Boolean value that indicates whether the calling thread 
should have initial ownership of the mutex, a string that is the name of the mutex, and a Boolean variable that, 
when the method returns, indicates whether the calling thread was granted initial ownership of the mutex, and the 
access control security to be applied to the named mutex.

Following are the parameters used in the constructors of the mutex class in C#:
1. **initiallyOwned**: true to give the calling thread initial ownership of the named system mutex if the named 
system mutex is created as a result of this call; otherwise, false.
2. **name**: The name of the Mutex. If the value is null, the Mutex is unnamed.
3. **createdNew**: When this method returns, contains a Boolean that is true if a local mutex was created 
(that is, if the name is null or an empty string) or if the specified named system mutex was created; false 
if the specified named system mutex already existed. This parameter is passed uninitialized.
4. **mutexSecurity**:  A System.Security.AccessControl.MutexSecurity object that represents the access control 
security to be applied to the named system mutex.

## Methods of the Mutex Class
The mutex class in C# provides the following methods:
1. **OpenExisting(string name)**: This method is used to open the specified named mutex if it already exists. 
It returns an object that represents the named system mutex. Here, the parameter name specifies the name of 
the system mutex to open. It will throw ArgumentException if the name is an empty string. -or- name is longer 
than 260 characters. It will throw ArgumentNullException if the name is null.
2. **OpenExisting(string name, MutexRights rights)**: This method is used to open the specified named mutex, if 
it already exists, with the desired security access. It returns an object that represents the named system mutex. 
Here, the parameter name specifies the name of the system mutex to open. The parameter rights specify a bitwise 
combination of the enumeration values that represent the desired security access.
3. **TryOpenExisting(string name, out Mutex result)**: This method is used to open the specified named mutex, 
if it already exists, and returns a value that indicates whether the operation succeeded. Here, the parameter 
name specifies the name of the system mutex to open. When this method returns, the result contains a Mutex object 
that represents the named mutex if the call succeeded, or null if the call failed. This parameter is treated as 
uninitialized. It returns true if the named mutex was opened successfully; otherwise, false.
4. **TryOpenExisting(string name, MutexRights rights, out Mutex result)**: This method is used to open the specified 
named mutex, if it already exists, with the desired security access, and returns a value that indicates whether the 
operation succeeded. Here, the parameter name specifies the name of the system mutex to open. The parameter rights 
specify a bitwise combination of the enumeration values that represent the desired security access. When this method 
returns, the result contains a Mutex object that represents the named mutex if the call succeeded, or null if the call 
failed. This parameter is treated as uninitialized. It returns true if the named mutex was opened successfully; 
otherwise, false.
5. **ReleaseMutex()**: This method is used to release Mutex once.
6. **GetAccessControl()**: This method gets a System.Security.AccessControl.MutexSecurity object that represents
the access control security for the named mutex. It returns a System.Security.AccessControl.MutexSecurity object 
that represents the access control security for the named mutex.
7. **SetAccessControl(MutexSecurity mutexSecurity)**: This method is used to set the access control security
for a named system mutex. The parameter mutexSecurity specifies a System.Security.AccessControl.MutexSecurity 
object that represents the access control security to be applied to the named system mutex.

**NOTE**:  
The Mutex Class in C# is inherited from WaitHandle class and the WaitHandle class provides the WaitOne() method 
which we need to call to lock the resource.  
A Mutex can only be released from the same thread which obtained it.

## Example to Understand Mutex in C# to Protect Shared Resource in Multithreading
The following example shows how a local Mutex object is used to synchronize access to a protected resource. Because 
each calling thread is blocked until it acquires ownership of the mutex, it must call the ReleaseMutex method 
to release ownership of the mutex.

```C#
using System;
using System.Threading;

namespace MutexExample
{
    internal class Program
    {
        private static Mutex mutex = new Mutex();

        static void Main(string[] args)
        {
            // create multiple threads to understand mutex
            for (int i = 1; i <= 5; i++)
            {
                Thread threadObject = new Thread(MutexDemo)
                {
                    Name = $"Thread {i}"
                };
                threadObject.Start();
            }
        }
        static void MutexDemo()
        {
            Console.WriteLine($"{Thread.CurrentThread.Name} wants to enter criticla section for processing");
            try
            {
                // Blocks the current thread until the current waitONe method receives a signal

                // wait until it is safer to enter
                mutex.WaitOne();
                Console.WriteLine($"Success: {Thread.CurrentThread.Name} is processing now.");
                Thread.Sleep(2000);
                Console.WriteLine($"Exit: {Thread.CurrentThread.Name} has completed its task.");
            }
            finally
            {
                mutex.ReleaseMutex();
            }
        }
    }
}
```

![Output](multithreading-mutex-example-output.png)

The Mutex Class is inherited from WaitHandle abstract class and the WaitHandle abstract class implements the
IDisposable interface. So, when you have finished using the type (in this case Mutex class), you should 
dispose of it either directly or indirectly.

To dispose of the type directly, call its Dispose method in a try/catch/finally block, even though you can 
also call it from the destructor. To dispose of it indirectly, use a language construct such as **using** block in C#.

As an example, we can call the dispose method from the destructor:

```C#
~Program()
{
    mutex.Dispose();
}
```
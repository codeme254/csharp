# Delegates

In C#, a delegate is a **type-safe function pointer.**

**It is a type that can hold a reference to a method with a specific signature and return type.**

<note>
Delegates are used to <b>pass methods as parameters</b>, implement <b>callbacks</b> and are the 
<b>foundation for events</b> in C#
</note>

Here is a quick example, we will be discussing this in details shortly:

```C#
// THIS CODE WAS GENERATED BY AI
using System;

public class Program
{
    // 1. Define a delegate type
    public delegate void MyDelegate(string message);

    // 2. Methods matching the delegate signature
    public static void MethodA(string msg)
    {
        Console.WriteLine("MethodA says: " + msg);
    }

    public static void MethodB(string msg)
    {
        Console.WriteLine("MethodB says: " + msg);
    }

    public static void Main()
    {
        // 3. Create delegate instances
        MyDelegate del = MethodA; // Assign MethodA
        del += MethodB;           // Add MethodB (multicast)

        // 4. Invoke delegate (calls both methods)
        del("Hello from delegate!");

        // 5. Remove a method
        del -= MethodA;
        del("Only MethodB now!");
    }
}

```

## Types of Delegates
There are two types of delegates in C# which we will discuss in details later:
- **Singlecast delegates/Unicast delegates**: refers to a delegate that invokes only one method.
- **Multicast delegates**: refers to a delegate that is used for invoking multiple methods.

Note: all the examples used throughout this section are Singlecast delegates.

## How to Create a Delegate
We can create a delegate using the **delegate** keyword.

The syntax for defining a delegate in C# is as follows:

```
<access modifier> delegate <return type> <delegate name> (parameter list);
```

Example:
```C#
public delegate void GreetDelegate(string name);
```

<note>
A delegate is a blueprint for a method as a class is a blueprint for an object.

The only difference is that a delegate defines what a method should look like i.e., return type and parameters and not
its implementation.
</note>

To use a delegate, we need to define one or more methods whose signatures match the delegate, i.e.:
- Same return type
- Same number, type and order of parameters.

These method(s) are usually referred to as **handler methods**.

![Example 1](delegates-example-1.png)

Note: the parameter names do not really matter, in the example above, the parameter name in the delegate is **name** but
in the handler methods we are using **username** and **nameOfUser**.

## How to Invoke A Delegate
First we create an instance of the delegate using the new keyword.

To the constructor, we pass the delegate handler method name.

With this in place, the way we call a delegate is very similar to the way we call a method, we call the delegate and 
pass the required arguments within parenthesis.

```C#
using System;

namespace Delegates
{
    internal class Program
    {
        public delegate void GreetDelegate(string name);

        static void SayHello(string username)
        {
            Console.WriteLine($"Hello {username}");
        }

        static void SayGoodbye(string nameOfUser)
        {
            Console.WriteLine($"Goodbye {nameOfUser}");
        }
        static void Main(string[] args)
        {
            // Since our handler method is static and we are in the same
            // class, we can access the handler method without an instance
            // or even the class name.
            GreetDelegate del1 = new GreetDelegate(SayHello);
            del1("John Doe"); // Hello John Doe

            // We can access the handler method using the class name if we want to
            // since the handler method is static
            GreetDelegate del2 = new GreetDelegate(Program.SayGoodbye);
            del2("John Doe"); // Goodbye John Doe
        }
    }
}
```

In our example, the handler method is static which means we don't need an instance of the class to invoke the method.

Also, since we are using these methods from the same class, if we want we can use the class name to access them or
use them directly.

However, if the method is non-static, you need to create an instance of the class to which the method belongs, using
that instance, you need to call the method inside the delegate constructor.

```C#
using System;

namespace Delegates
{
    internal class DelegateExample
    {
        public delegate void GreetDelegate(string name);

        void SayHello(string username)
        {
            Console.WriteLine($"Hello {username}");
        }

        void SayGoodbye(string nameOfUser)
        {
            Console.WriteLine($"Goodbye {nameOfUser}");
        }
        static void Main(string[] args)
        {
            DelegateExample de = new DelegateExample();

            GreetDelegate del1 = new GreetDelegate(de.SayHello);
            del1("John Doe");
            GreetDelegate del2 = new GreetDelegate(de.SayGoodbye);
            del2("Jane Doe");
        }
    }
}
```

## Using the `Invoke` Method to Invoke a Delegate
We can also use the **Invoke** method to invoke a delegate:

```C#
using System;

namespace Delegates
{
    internal class DelegateExample
    {
        public delegate void GreetDelegate(string name);

        void SayHello(string username)
        {
            Console.WriteLine($"Hello {username}");
        }

        void SayGoodbye(string nameOfUser)
        {
            Console.WriteLine($"Goodbye {nameOfUser}");
        }
        static void Main(string[] args)
        {
            DelegateExample de = new DelegateExample();

            GreetDelegate del1 = new GreetDelegate(de.SayHello);
            //del1("John Doe");
            del1.Invoke("John Doe");

            GreetDelegate del2 = new GreetDelegate(de.SayGoodbye);
            //del2("Jane Doe");
            del2.Invoke("Jane Doe");
        }
    }
}
```

## Delegate Base Class
One of the really core classes in the .NET Framework is Delegate which provides some base functionalities.

If you go to the definition of the Delegate class, then you will see that it is an abstract class as shown in 
the below image.

![Delegate Base Class](delegates-delegate-base-class.png)

The delegate class provides two important properties as follows:
1. `public MethodInfo Method { get; }`: this property is used to get the method represented by the delegate. Think of
this as **"which method am I pointing to"**, it gives you information about the method itself (name, return type, 
parameters, e.t.c). If the method is private, and you don't have permission to access it, you'll get an error.
2. `public object Target { get; }`: think of this as **"to which object does this method belong to"**, if the delegate
points to a normal(instance) method, this gives you the object on which the method will run on, if the delegate points
to a static method meaning there's no object, it returns null.

The delegate class also has one important method called: **GetInvocationList**:
- `public virtual Delegate[] GetInvocationList()`: This method returns an array of delegates, each one 
representing a single method that’s part of the delegate’s invocation list (that’s just a fancy 
term for **"the list of methods the delegate will call"**).

## MulticastDelegate Base Class
Another important class that deals with delegates in C# is the **MulticastDelegate** class.

If you go to the definition of this class, you will see that this class is also an abstract class and is inherited
from the Delegate abstract class as shown:

![MulticastDelegate Base Class](delegates-multicastdelegate-base-class.png)

Note: **Every delegate that we create, once compiled, will inherit from MulticastDelegate**.

The order now is that our delegate inherits from MulticastDelegate base class which inherits from Delegate base class.

![Hierarchy](delegates-inheritance-hierarchy.png)

In your code while declaring the delegate, you cannot directly inherit from the Delegate or Multicast Delegate 
classes. The way you need to do this is to use the delegate keyword and the rest of the things are done by the compiler.

These are the special base classes that the compiler restricts us from directly inheriting. Once the compiler sees 
the delegate keyword in the signature, then it will automatically generate the class that inherits from the 
Multicast Delegate.

## Delegates for Callback Functions/Methods
A callback is a function passed as an argument to another function, allowing the latter to execute the 
callback at a specific point in its execution.

Delegates make it possible to work with callbacks in C#.

As you can see in the below example, we have two methods i.e. `DoSomework` and `ExampleCallback`.

From our Main method, we want to invoke the `DoSomework` method, but we also want to `DoSomework` method to invoke 
one method dynamically at runtime, and that method we will provide at runtime.

To do so, we want the `DoSomework` method accepts the delegate as a parameter and at some point, we need to 
invoke the delegate within the `DoSomework` method.

Here, we are creating an instance of the delegate within the main method which is referring to the `ExampleCallback`, 
and passing that delegate instance as a value to the `DoSomework` method and at runtime when the `DoSomework` 
method invokes the delegate, the method which is pointed by the delegate, in this case, `ExampleCallback` method 
is going to be executed.
```C#
using System;

namespace Callbacks
{
    public delegate void Callback(string username);
    internal class Callbacks
    {
        static void Main(string[] args)
        {
            Callback del = new Callback(ExampleCallback);
            DoSomeWork(del);
        }

        static void DoSomeWork(Callback cb)
        {
            Console.WriteLine("Some work has been completed...");
            cb("John Doe.");
        }

        static void ExampleCallback(string username)
        {
            Console.WriteLine("This is the callback method");
            Console.WriteLine($"Hello {username}");
        }
    }
}
```
![Output](delegates-callback-method.png)

## Rules of Using Delegates in C#
1. A delegate in C# is a user-defined type and hence before invoking a method using a delegate, we must have to
define that delegate first.
2. The signature of the delegate must match the signature of the method the delegate points to, otherwise 
we will get a compiler error. This is the reason why delegates are called type-safe function pointers.

## Where do We Use Delegates
- Event handlers
- Callbacks
- Passing methods as Method Parameters
- LINQ
- Multithreading
